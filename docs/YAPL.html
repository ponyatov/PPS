<title>YAPL/js</title>
<meta name="theme-color" content="black">
<link rel="icon" type="image/png" href="hedge64x64.png">
<link rel="manifest" href="/YAPL.manifest">

<style>

* {
	background: black; color: lightgreen;
	font-family: monospace, monospace; font-size: 2vh;
	margin: 0; 
}

textarea { width:100%; caret-color:red; }
button   { width:100%; background: darkslategray; height: 11vmin; }

#stack,#pad { color: cyan; }

#cmd { position: absolute; bottom:0; width:100%; }

</style>

<pre id=log># log
See more at <a href="https://ponyatov.quora.com/YAPL-Yet-Another-Programming-Language-script-engine-in-JavaScript">quora</a>.
</pre>

<pre id=stack>stack:data</pre>

<div id=cmd>

<textarea id=meta rows=7>// PEG grammar

{ log.innerText = '' }

FORTH "metacompiler" = (
  _ / comment  /* drop */
  / n:number   { doit(n) }
  / w:wordname { doit(w) }
) *

comment =
    [#\\][^\n]*   // line
  / '(' [^)]* ')' // block

_ "drop spaces" = [ \t\r\n]+

wordname = w:[^ \t\r\n]+
  { return new Sym(join(w)) }

number =
    pfx:'0x' hex:[0-9a-fA-F]+
    { return new Hex(pfx+join(hex)) }
  / pfx:'0b' bin:[01]+
    { return new Bin(pfx+join(bin)) }
  / int:(S N)
    flo:('.' N)?
    exp:([eE] S N)?
    {
      if (!flo && !exp)
        return new Int(join(int))
      else
        return new Num(
          join(int)+
          join(flo)+join(exp))
    }
      
S = [\+\-]? // sign
N = [0-9]+  // number

</textarea>

<textarea id=pad rows=5> # line comment

-01 +02.30 -4e+56  \ numbers
0xDeadBeef 0b1101  ( machine ) ? .

undefined_word

: none ;
: recurse none recurse none ;

</textarea>
<button id=go>GO</button>
</div>

<script src=PEG.js></script>

<script>

// generic base object: constructor from <tag:value>
function Qbject(V) {
	
	// object class/type in simple string form
	this.type	= this.constructor.name.toLowerCase()
	// single value
	this.value	= V
	
	// attr{}ibutes
	this.attr	= {}
	// assign attribute
	this.set	= function(key,obj) { this.attr[key] = obj; }
	// get attribute
	this.get	= function(key) { return this.attr[key] }
	// get list of attributes
	this.keys	= function() { return Object.keys(this.attr) }
	
	// nest[]ed objects
	this.nest	= []
	// push object to nested as a stack
	this.push	= function(obj) { this.nest.push(obj) ; return this }
	// pop object from stack
	this.pop	= function() { return this.nest.pop() }
	// clean stack
	this.dropall = function() { this.nest = [] }
	
	// execute object in context = stack
	this.exec	 = function(context) { context.push(this) }
	// compile object to context = vector
	this.compile = function(context) { context.push(this) }
	
	// short object dump in <T:V> form
	this.head	= function() { return "<"+this.type+":"+this.value+">" }
	// dump object in full tree form
	this.dump	= function(depth=0) {
		var T = this.pad(depth) + this.head()
		for (i in this.attr) T += this.attr[i].dump(depth+1,prefix=i)
		for (j in this.nest) T += this.nest[j].dump(depth+1)
		return T
	}
	// left pad for tree form
	this.pad	= function(N) { return '\n' + '    '.repeat(N) }
}

function Primitive(V)	{ Qbject.call(this,V) }

function Sym(V)		{
	Primitive.call(this,V)
	this.exec = function() {
		// lookup in vocabulary
		var body = W.get(V)
		// execute found body
		if (body) body.exec()
		// or fallback: push symbol on stack itself
		else      S.push(this)
	}
}

function Str(V)		{ Primitive.call(this,V) }

function Num(V)		{ Primitive.call(this,V)
					  this.value = parseFloat(V) }
function Int(V)		{ Primitive.call(this,V)
					  this.value = parseInt(V) }
function Hex(V)		{ Primitive.call(this,V)
					  this.value = parseInt(V.substring(2),0x10) }
function Bin(V)		{ Primitive.call(this,V)
					  this.value = parseInt(V.substring(2),0x02) }

function Container(V)	{ Qbject.call(this,V) }

function Stack(V)		{ Container.call(this,V) }

function Map(V)			{ Container.call(this,V) }

function Vector(V)		{ Container.call(this,V) }

//active objects has executable semantics
function Active(V)	{ Qbject.call(this,V) }

// JS function wrapper as virtual machine command
function Cmd(V,F)	{ Active.call(this,V) ; this.exec = F }


S = new Stack('data') // global
S.push(new Int(1.23))
S.push(new Num(1.23))

function update() { stack.innerText = S.dump() }

function process() {
	// create parser
	var parser = peg.generate(meta.value)
	// and run it vith #pad value
	parser.parse(pad.value)
	// update web interface 
	update()
}

function keydown(event) {
	if (event.ctrlKey & event.key == 'Enter') process()
}

window.onload = function() {
	init_vocabulary()
	go.onclick = process
	document.body.onkeydown = keydown
	update()
}

function wrap(some) {
	JSON.stringify(some)
		.match(/.{1,44}/g)
		.forEach(function(item,i,arr)
			{ S += item + '\n' } )
	return S	
}

function out(some) { log.innerText += wrap(some) }

function flat(vector) { return [].concat.apply([],vector) }
function join(token)  { return flat(token).join('') }
function push(obj)    { S.push(obj) }

COMPILE = false

function doit(obj) {
	if (COMPILE) obj.compile(COMPILE)
	else		 obj.exec(S)
}

W = new Map('vocabulary')

function init_vocabulary() {
	// clear stack
	// (use at end of processing block for cleanup)
	W.set('.', new Cmd('.',function() {
		S.dropall() }))
	// dump data stack to log
	W.set('?', new Cmd('?',function() {
		log.innerText += S.dump() ; update() }))
}

</script>